封锁可以避免数据的不一致性，但有可能引起 若干事务彼此等待对方释放封锁

在数据系统中，对存取权限的定义称为 授权

数据库中，数据的逻辑独立性是指 应用程序与数据库中数据的逻辑结构相互独立

同一个关系模型的任两个元组值 不能全同。 一个关系都对应于一个二维表，表的每一行对应一个元组，一个二维表中，要求不同行之间元素不能完全相同。

子模式 DDL 用来描述 数据库的局部逻辑结构

外模式也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，
是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 
理解： ① 一个数据库可以有多个外模式； ② 外模式就是用户视图； ③ 外模式是保证数据安全性的一个有力措施。

数据库设计通常分为6个阶段
1需求分析：分析用户的需求，包括数据、功能和性能需求；
2概念结构设计：主要采用E-R模型进行设计，包括画E-R图；
3逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；
4数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；
5数据库的实施：包括编程、测试和试运行；
6数据库运行与维护：系统的运行与数据库的日常维护。
主要讨论其中的第3个阶段,即逻辑设计。通过一个实际的案例说明在逻辑设计中E-R图向关系模式的转换。

两阶段封锁协议的定义：能真正保证调度可串行化的封锁协议是两阶段封锁协议，该协议要求每个事务分两个阶段提出加锁和解锁申请：
增长阶段：事务可以获得锁，但不能释放锁  -　缩减阶段：事务可以释放锁，但不能获得新锁
对于一个事务而言，刚开始事务处于增长阶段，它可以根据需要获得锁；一旦该事务开始释放锁，它就进入了缩减阶段，就不能再发出加锁请求。
值得注意的是：**事务的第一个解锁语句unlock被执行的时刻就是该事物缩减阶段的开始。**

在SQL语言中的视图VIEW是数据库的 外模式

用矩形表示实体型；用椭圆表示实体的属性；用菱形表示实体型之间的联系

事务的原子性是指事务中包括的所有操作要么都做，要么都不做

数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作。 
原子性（Atomic）（Atomicity) 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。 
一致性（Consistent）(Consistency) 事务在完成时，必须使所有的数据都保持一致状态。 
隔离性（Insulation）(Isolation) 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。 
持久性（Duration）(Durability） 事务完成之后，它对于系统的影响是永久性的。

“查询”设计视图窗口分上下部分；
上部分为：“字段列表区”，用来显示所选择的所有字段。
下部分为：设计网络，由一些字段列和一些已命名的列组成。

两段锁协议是指所有事务必须分两个阶段对数据项加锁和解锁。
两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。
加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。
加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

关系规范化中的删除操作异常是指不该删除的数据被删除
应该删除的数据未被删除是删除失败

层次模型
    层次模型是以记录类型为结点的树型结构，下层记录是上层记录中某元素的细化。
    层次模型的记录类型间只有简单的层次关系，且满足以下条件：有一个记录类型没有父结点；其他记录类型有且只有一个父结点。
网状模型
    有一个以上记录类型没有父结点；至少有一个记录类型多于一个父结点。用这种网络结构表示记录类型之间联系的模型称为网状模型。
关系模型
    关系模型的基本思想是把事物与事物之间的联系用二维表格的形式描述。
    一个关系可以看作一个二维表，表中每一行是一个记录，每一列是一个字段。
    关系模型可用离散数学中的关系代数来描述，因而关系数据库管理系统能够用严格的数学理论来描述数据库的组织和操作，
    且具有简单灵活、数据独立性高等特点，应用十分广泛

数据库系统必须提供的数据控制功能：完整性，安全性，并发控制

"空值" 和"NULL"的概念：
  1：空值('')是不占用空间的,判断空字符用 = '' 或者 <> '' 来进行处理;
 2: NULL值是未知的，且占用空间，不走索引;判断 NULL 用 IS NULL 或者 is not null , SQL 语句函数中可以使用 ifnull ()函数来进行处理.
注：在进行 count ()统计某列的记录数的时候，如果采用的 NULL 值，会别系统自动忽略掉，但是空值是统计到其中 

SQL 通配符必须与 LIKE 运算符一起使用。%可以表示0,1，多个字符

第二范式是在第一范式的基础上消除了非主属性对键的部分函数依赖

范式是符合某一种级别的关系模式的集合。关系数据库中的关系必须满足一定的要求，满足不同程度要求的为不同范式。
目前关系数据库有六种范式：第一范式（1NF）、第二范式（ 2NF ）、第三范式（ 3NF ）、 
Boyce-Codd 范式（ BCNF ）、第四范式（ 4NF ）和第五范式（ 5NF ）。满足最低要求的范式是第一范式（ 1NF ）。
在第一范式的基础上进一步满足更多要求的称为第二范式（ 2NF ），其余范式以次类推。
一般说来，数据库只需满足第三范式（ 3NF ）就行了。
第一范式：主属性（主键）不为空且不重复，字段不可再分（存在非主属性对主属性的部分依赖）。 
第二范式：如果关系模式是第一范式，每个非主属性都没有对主键的部分依赖。 
第三范式：如果关系模式是第二范式，没有非主属性对主键的传递依赖和部分依赖。 
BCNF 范式：所有属性都不传递依赖于关系的任何候选键。

1.having只能用在group by之后，对分组后的结果进行筛选，筛选行(即使用having的前提条件是分组)。不是列，列是在select中选择输出的
2.where肯定在group by 之前
3.where后的条件表达式里不允许使用聚合函数，而having可以。

1.主键约束（PRIMARY KEY）

1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。 
2) 是不可能（或很难）更新． 
3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．
4) 主健可作外健，唯一索引不可；

2.唯一性约束（UNIQUE）
1) 唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．
2) 只要唯一就可以更新． 
3) 即表中任意两行在  指定列上都不允许有相同的值，允许空（NULL）．
4) 一个表上可以放置多个唯一性约束

3.唯一索引（INDEX）
创建唯一索引可以确保任何生成重复键值的尝试都会失败。

唯一性约束和主键约束的区别：
    （1）.唯一性约束允许在该列上存在NULL值，而主键约束的限制更为严格，不但不允许有重复，而且也不允许有空值。
    （2）.在创建唯一性约束和主键约束时可以创建聚集索引和非聚集索引，但在 默认情况下主键约束产生聚集索引，而唯一性约束产生非聚集索引

约束和索引， 前者是用来检查数据的正确性，后者用来实现数据查询的优化，目的不同。

唯一性约束与唯一索引有所不同：
（1）.创建唯一约束会在Oracle中创建一个Constraint，同时也会创建一个该约束对应的唯一索引。
（2）.创建唯一索引只会创建一个唯一索引，不会创建Constraint。

也就是说其实唯一约束是通过创建唯一索引来实现的。
在删除时这两者也有一定的区别：
删除唯一约束时可以只删除约束而不删除对应的索引，所以对应的列还是必须唯一的，
而删除了唯一索引的话就可以插入不唯一的值

1、表的主键、外键必须有索引；
2、数据量超过300的表应该有索引；
3、经常与其他表进行连接的表，在连接字段上应该建立索引；
4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5、索引应该建在选择性高的字段上；
6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：

select... into...from 和 insert... into... select...from...都是用来复制表，
两者的主要区别为： select into from 要求目标表不存在，因为在插入时会自动创建。
insert into select from 要求目标表存在

数据库系统中的关系所属范式越高越好，因为所属范式越高，数据库冗余越少，
但存储表所站内存开销不会越小，因为数据库的冗余减少有一部分是通过分表完成的。
一般来说，3NF基本解决数据库的数据冗余过大，插入异常，删除异常，修改异常的问题。

从E-R图向关系模型的转换所遵循的转换原则是：①一个实体转换为一个关系模式，实体的属性就是关系的属性，实体的关键字就是关系的关键字；
②一个联系转换为一个关系模式，与该联系相连的各实体的码以及联系的属性转换为该关系的属性。
该关系的码有以下3种情况：
一个1:1的联系转换为一个关系，相连实体的关键字都是关系的侯选关键字；
一个1:n的联系转换为一个关系，多方实体的关键字是关系的关键字；
一个n:m的联系转换为一个关系，相连实体的关键字的组合组成关系的关键字(复合关键字)。

基本的封锁类型有两种：排它锁(Exclusive Locks，简称X锁)和共享锁(Share Locks，简称S锁)。
(1)排它锁
排它锁也称为独占锁或写锁。一旦事务T对数据对象A加上排它锁(X锁)，则只允许T读取和修改A，其他任何事务既不能读取和修改A，
也不能再对A加任何类型的锁，直到T释放A上的锁为止。
(2)共享锁
共享锁又称读锁。如果事务T对数据对象A加上共享锁(S锁)，其他事务对A只能再加S锁，不能加X锁，直到事务T释放A上的S锁为止。

PreparedStatement的一个缺点是，我们不能直接用它来执行in条件语句；需要执行IN条件语句的话，下面有一些解决方案：
分别进行单条查询——这样做性能很差，不推荐。
使用存储过程——这取决于数据库的实现，不是所有数据库都支持。
动态生成PreparedStatement——这是个好办法，但是不能享受PreparedStatement的缓存带来的好处了。
在PreparedStatement查询中使用NULL值——如果你知道输入变量的最大个数的话，这是个不错的办法，扩展一下还可以支持无限参数。

JDBC PreparedStatement可以用来进行动态查询,通过预编译和缓存机制提升了执行的效率
有助于防止SQL注入，因为它会自动对特殊字符转义
















