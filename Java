有时为了避免某些未识别的异常抛给更高的上层应用，在某些接口实现中我们通常需要捕获编译运行期所有的异常， catch Exception类的实例才能达到目的
因为error是系统出错，catch是无法处理的，难以修复的，RuntimeException不需要程序员进行捕获处理，
error和exception都是throwable的子类，我们只需要对exception的实例进行捕获即可

Java中，数据类型分为基本数据类型（或叫做原生类、内置类型）和引用数据类型。

构造函数不能被继承，构造方法只能被显式或隐式的调用。

Java 的屏幕坐标是以像素为单位，容器的左上角被确定为坐标的起点。

byte能表示的范围[-128,127]

运行异常，可以通过java虚拟机来自行处理。非运行异常，我们应该捕获或者抛出

以非new形式创建一个字符串a首先会字符串池查找有没有相同的字符串，如果有，就把相同字符串的首地址赋给a
==是比较地址值是否相等，.equals()方法是比较值是否相等

Spring 支持 7 种事务传播行为：
PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。
PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。
PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。
PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。


int i = 5;
int j = 10;
System.out.println(i + ~j);
公式-n=~n+1可推出~n=-n-1，所以~10=-11再加5结果为-6

JSP内置对象有：
1.request对象
     客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。
2.response对象
     response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。
3.session对象
     session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.
4.out对象
     out对象是JspWriter类的实例,是向客户端输出内容常用的对象
5.page对象
     page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例
6.application对象
     application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。
7.exception对象
   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象
8.pageContext对象
pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。
9.config对象
config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

方法是可以和类名同名的，和构造方法唯一的区别就是，构造方法没有返回值

Exception和Error都是Throwable的子类： 
1.Exception（异常） :是程序本身可以处理的异常。 
2.Error（错误）: 是程序无法处理的错误。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，一般不需要程序处理。
3.检查异常（编译器要求必须处置的异常） ：  除了Error，RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。
4.非检查异常(编译器不要求处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）

1.抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字只能描述类和方法，不能描述变量，不修饰字段（属性）。
抽象方法只定义方法声明，不定义方法实现。
抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。
抽象类中有构造函数用于给子类对象进行初始化，同时抽象类中可以含有非抽象方法。
abstract关键字不可以与final，private,static关键字共存，因为被final修饰的方法不可以被重写，
意味着子类不可以重写该方法，如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。
如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。
如果static和abstract共同修饰父类中的方法，static表示是静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现，这与abstract关键字矛盾。 

2.static用于修饰成员变量和成员函数，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰，被静态修饰的成员可以直接被类名调用，
静态随着类的加载而加载，而且优先于对象存在。静态方法只能访问静态成员（静态方法和静态变量），不可以访问非静态成员，
这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。
静态方法中不能使用this和super关键字，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。 

3.final关键字可以修饰类，方法，变量（成员变量内，局部变量，静态变量），被final修饰的类是一个最终类，不可以被继承，
被final修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。
被final修饰的变量只能是一个常量，只能赋值一次。
内部类被定义在类中的局部位置上时，只能访问局部被final修饰的局部变量。

接口中属性为public static final。方法为public abstract。

子类的权限不能比父类更低

析构函数(destructor) 与构造函数相反，当对象结束其 生命周期时（例如对象所在的函数已调用完毕），
系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。

Stack是栈， queue是队列；
栈是后进先出，对列是先进先出；
栈是出入从同一个位置；
对列是入从结构的一端进入，从另一端出队；
栈就像一个盒子，你把物体依次放入后，能先拿出来的只能是上面最后放进去的，下层的想要拿出需要将上层的先拿出，也就是先出栈；
对列是一个胡同，人们都进入胡同了，只有最前面的人从胡同出口出去，后面的人只有等前面的人走完后才能依次通过。

final类是不能继承的

被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量

接口方法默认是public abstract的，且实现该接口的类中对应的方法的可见性不能小于接口方法的可见性，因此也只能是public的。

抽象方法没有方法体，也不用大括号。

抽象方法用“;”结束

java.io.Reader是一个读取字符流的抽象类，通过继承Reader类，可以很方便的读取字符流，
     比如，我们可以将一个字符串读取为一串串（字符）流，还可以读取一个文件里的内容为一串串的流。
Java(1.6.x)里提供了几种Reader的直接继承类，具体的有：
BufferedReader, CharArrayReader, FileReader, InputStreamReader, PipedReader, StringReader等，
子类须实现的方法只有 read(char[], int, int) 和 close()

HashMap不能保证元素的顺序,HashMap能够将键设为null，也可以将值设为null，
与之对应的是Hashtable,(注意大小写：不是HashTable)，
Hashtable不能将键和值设为null，否则运行时会报空指针异常错误；
HashMap线程不安全，Hashtable线程安全

1.Statement、PreparedStatement和CallableStatement都是接口(interface)。  
2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。  
3.  
Statement接口提供了执行语句和获取结果的基本方法；  
PreparedStatement接口添加了处理 IN 参数的方法；  
CallableStatement接口添加了处理 OUT 参数的方法。  
4.  
a.Statement:  
普通的不带参的查询SQL；支持批量更新,批量删除;  
b.PreparedStatement:  
可变参数的SQL,编译一次,执行多次,效率高;  
安全性好，有效防止Sql注入等问题;  
支持批量更新,批量删除;  
c.CallableStatement:  
继承自PreparedStatement,支持带参数的SQL操作;  
支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;  

Statement每次执行sql语句，数据库都要执行sql语句的编译 ，  
最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。  

PreparedStatement是预编译的，使用PreparedStatement有几个好处  
1. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。  
2. 安全性好，有效防止Sql注入等问题。  
3.  对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；  
4.  代码的可读性和可维护性。

类的加载包括：加载，验证，准备，解析，初始化。
生成java.lang.Class对象是在加载时进行的。生成Class对象作为方法区这个类的各种数据的访问入口

对于JVM内存配置参数：
-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3
-Xmx：最大堆大小
-Xms：初始堆大小
-Xmn:年轻代大小
-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值
年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。
-Xms初始堆大小即最小内存值为10240m

简单地说，字符流是字节流根据字节流所要求的编码集解析获得的
可以理解为字符流=字节流+编码集
和字符流有关的类都拥有操作编码集(unicode)的能力

字节流：
InputStream   
|-- FileInputStream (基本文件流）   
|-- BufferedInputStream   
|-- DataInputStream   
|-- ObjectInputStream
字符流
Reader 
|-- InputStreamReader (byte->char 桥梁） 
|-- BufferedReader (常用） 
Writer 
|-- OutputStreamWriter (char->byte 桥梁） 
|-- BufferedWriter 
|-- PrintWriter （常用

java程序的入口必须是static类型的，接口中不允许有static类型的方法
interface中的方法默认为public abstract 的 ，变量默认为public static final

1. 只看尖括号里边的！！明确点和范围两个概念
2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List<A>,List<B>,List<Object>
3. 如果尖括号里面带有问号，那么代表一个范围，<? extends A> 代表小于等于A的范围，<? super A>代表大于等于A的范围，<?>代表全部范围
4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点
5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值
6. List<?>和List 是相等的，都代表最大范围
----------------------------------------------------------------------------------
7.补充：List既是点也是范围，当表示范围时，表示最大范围

jvm中垃圾回收分为scanvenge gc和full GC，

为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。
     如果没有指定包名，所有的示例都属于一个默认的无名包。
     Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，
     java的包是用来组织文件的一种虚拟文件系统。
import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。
Java提供的包机制与IDE没有关系。
定义在同一个包（package）内的类可以不经过import而直接相互使用

ArrayList是基于数组实现的，所以查询快，增删慢；LinkedList是基于链表实现的，所以查找慢，增删快。

this和super的区别
     1）调用super()必须写在子类构造方法的第一行，否则编译不通过。
     每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
     2）super()和this()类似,区别是，super从子类中调用父类的构造方法，this()在同一类内调用其它方法。
     3）super()和this()均需放在构造方法内第一行。
     4）尽管可以用this调用一个构造器，但却不能调用两个。
     5）this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，
     其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。
     6）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
     7）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字

覆盖又叫覆写，重写。     与重载是两个概念






